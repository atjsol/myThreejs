<html>
	<head>
	  <title>My first Three.js app</title>
	  <!-- uncomment line blow for served file
	  <script src="js/three.min.js"></script>
	       -->
	  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r71/three.js"></script>
	 

	  <script src="./OrbitControls.js"></script>
	  <style>
	    body {
	        margin: 0;
	        background-color: #f0f0f0;
	    }

	    canvas {
	        position:absolute;
	        width: 100%;
	        height: 90%;
	    }
	    td {
	        border: 1px solid red;
	        height: 10%
	    }
	  </style>
	</head>
  <body>
   
    <script>
			var scene = new THREE.Scene();

			var camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 10000 );

			// camera.position.z = 1000;
			camera.position.y = 340;
			scene.add( camera );

			var renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild( renderer.domElement );
			
			var light = new THREE.PointLight( 0xffffff, 0.8 );
			camera.add( light );

			var group = new THREE.Group();
			group.position.y = 0;
			scene.add( group )

			var outlinePoints = [];

			
			function randomShape (sides){
				for (var i =0; i < sides; i++){
					outlinePoints.push( new THREE.Vector2(Math.random()*100, Math.random()*100))
				}
			}

			// randomShape(8);

			// up is Z!
			function drawCenter(){
				var centerDraw = [];
				centerDraw.push(new THREE.Vector3( 5,0, 0));
				centerDraw.push(new THREE.Vector3(0, 0,10));
				centerDraw.push(new THREE.Vector3(-5,0, 0));
				var center = new THREE.Shape(centerDraw);
				// addShape(center, extrudeSettings, 0xf08000, 0, 10, 0, 0, 0, 0, 1);	
				// var points = center.createPointsGeometry();
				// var spacedPoints = center.createSpacedPointsGeometry( 4 );	
				var geometry = new THREE.ShapeGeometry( center );

				var mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { color: 0xffffff, side: THREE.DoubleSide } ) );
				group.add( mesh );		
			}
			// drawCenter();

			function axisZ(spacing, rows){
				spacing = spacing ? spacing : 20;
				rows = rows ? rows : 10;
				var material = new THREE.LineBasicMaterial({
					color: 0x0000ff
				});
				var offsetCenter = spacing * rows/2
				var geometry = new THREE.Geometry();
				for (var i = 0; i < rows; i ++){
					geometry.vertices.push(new THREE.Vector3(spacing * i - offsetCenter, 0, -100));
					geometry.vertices.push(new THREE.Vector3(spacing * i - offsetCenter, 0, 100));
					geometry.vertices.push(new THREE.Vector3(-100, 0 , spacing * i - offsetCenter));
					geometry.vertices.push(new THREE.Vector3(+100, 0 , spacing * i - offsetCenter));
					var line = new THREE.Line( geometry, material );
					scene.add( line );
				}
			}
			axisZ();
			

			// var outline = new THREE.Shape( outlinePoints );

			var extrudeSettings = { amount: 1, bevelEnabled: true, bevelSegments: 2, steps: 2, bevelSize: 1, bevelThickness: 1 };

			// addShape( shape, color, x, y, z, rx, ry,rz, s );
			// addShape( outline,  extrudeSettings, 0xf08000, 0, 0, 0, 0, 0, 0, 1 );

			//function taken from http://threejs.org/examples/webgl_geometry_shapes.html
			function addShape( shape, extrudeSettings, color, x, y, z, rx, ry, rz, s ) {

					var points = shape.createPointsGeometry();
					var spacedPoints = shape.createSpacedPointsGeometry( 50 );

					// flat shape with texture
					// note: default UVs generated by ShapeGemoetry are simply the x- and y-coordinates of the vertices

					// var geometry = new THREE.ShapeGeometry( shape );

					// var mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { side: THREE.DoubleSide} ) );
					// mesh.position.set( x, y, z - 175 );
					// mesh.rotation.set( rx, ry, rz );
					// mesh.scale.set( s, s, s );
					// group.add( mesh );

					// // flat shape

					// var geometry = new THREE.ShapeGeometry( shape );

					// var mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { color: color, side: THREE.DoubleSide } ) );
					// mesh.position.set( x, y, z);
					// mesh.rotation.set( rx, ry, rz );
					// mesh.scale.set( s, s, s );
					// group.add( mesh );

					// 3d shape

					var geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );

					var mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { color: color } ) );
					mesh.position.set( x, y, z );
					mesh.rotation.set( rx, ry, rz );
					mesh.scale.set( s, s, s );
					group.add( mesh );

					// solid line

					// var line = new THREE.Line( points, new THREE.LineBasicMaterial( { color: color, linewidth: 3 } ) );
					// line.position.set( x, y, z - 25 );
					// line.rotation.set( rx, ry, rz );
					// line.scale.set( s, s, s );
					// group.add( line );

					// // vertices from real points

					// var pgeo = points.clone();
					// var particles = new THREE.PointCloud( pgeo, new THREE.PointCloudMaterial( { color: color, size: 4 } ) );
					// particles.position.set( x, y, z + 25 );
					// particles.rotation.set( rx, ry, rz );
					// particles.scale.set( s, s, s );
					// group.add( particles );

					// line from equidistance sampled points

					// var line = new THREE.Line( spacedPoints, new THREE.LineBasicMaterial( { color: color, linewidth: 3 } ) );
					// line.position.set( x, y, z + 75 );
					// line.rotation.set( rx, ry, rz );
					// line.scale.set( s, s, s );
					// group.add( line );

					// equidistance sampled points

					// var pgeo = spacedPoints.clone();
					// var particles2 = new THREE.PointCloud( pgeo, new THREE.PointCloudMaterial( { color: color, size: 4 } ) );
					// particles2.position.set( x, y, z + 125 );
					// particles2.rotation.set( rx, ry, rz );
					// particles2.scale.set( s, s, s );
					// group.add( particles2 );
			}

			//if you do not have an animation loop, it will not work;
			function animate (){
				
				renderer.render( scene, camera );
				requestAnimationFrame(animate);
			}

      function addMouseControl() {
      	//orbit controls taken from http://www.smartjava.org/ltjs/chapter-05/03-basic-2d-geometries-shape.html
      	controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true;
				controls.dampingFactor = 0.25;
				controls.enableZoom = true;
      };
			animate();
      addMouseControl();

      var mouse = {x:0, y:0};
      window.addEventListener("mousemove", function (event){
      	mouse.x = event.x;
      	mouse.y = event.y;
      	mouse.normalX = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.normalY = - ( event.clientY / window.innerHeight ) * 2 + 1;
      });

      var shapeQue = [];
      var shapeNum = 0;

      window.addEventListener("keyup", function (event){
      	

      	if (event.which === 65 ){ // a key
      		shapeQue[shapeNum] = shapeQue[shapeNum] === undefined ? [] : shapeQue[shapeNum];
   				shapeQue[shapeNum].push(new THREE.Vector2(mouse.normalX*100, mouse.normalY*100));
      	}
  	   	if (event.which === 13 ){ // enter key
   				shapeNum++;
   				shapeQue.forEach(function (outline){
   					
   					var newOutline =  new THREE.Shape();
   					// set initial xy
   					
   					outline.forEach(function (coordinates, i) {
   						console.log(coordinates);
   						if (i === 0){
	   						newOutline.moveTo(coordinates.x,coordinates.y);
   							
   						} else {
	   						newOutline.lineTo(coordinates.x, coordinates.y);
 
   						}
   					});
   					addShape(newOutline, extrudeSettings, 0xf08000, 0, 20, 0, Math.PI*68/180, 0, 0, 1 );
   				});
      	}
      });
    </script>

    
  </body>
</html>